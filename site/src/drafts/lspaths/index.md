---
title: Lakshmibai-Seshadri paths
---

<script type="module">
    import Paths from './Paths.svelte'

    new Paths({target: document.getElementById('Paths')})
</script>

<style>
    section > figure {
        height: min(90vh, 800px);
    }
</style>

In Littelmann's *Inventiones Mathematicae* paper *A Littlewood-Richardson rule for symmetrizable Kac-Moody algebras*, the notion of a [Laskshmibai-Seshadri path]{.defn} or [LS path]{.defn} was defined. The basic idea is to generalise the notion of semistandard Young tableaux into any symmetrisable Kac-Moody type by replacing the tableau by a piecewise-linear path in the weight lattice, starting at 0 and ending at a weight. Suitable $e_i$ and $f_i$ operators can be defined on the set of paths, giving it the structure of a crystal.

A [path]{.defn} in this context is a piecewise-linear path $\pi \colon [0, 1] \to X_\bbR$ in the weight space, starting at the origin ($\pi(0) = 0$), with two paths being considered equal if one is a reparametrisation of the other. Each root operator acts by cutting the path into three pieces $\pi = \pi_1 * \pi_2 * \pi_3$, where $*$ is a suitable concatenation of paths-starting-at-the-origin. The root operator either kills the path, or returns $\pi_1 * s_\alpha(\pi_2) * \pi_3$.

For a dominant weight $\lambda$, let $\pi_\lambda$ be the path connecting the origin to $\lambda$ in a straight line. The set of [LS paths of shape $\lambda$]{.defn} are as the set of paths generated by repeatedly acting on $\pi_\lambda$ by the $f_\alpha$. This set of paths under the $e_\alpha$ and $f_\alpha$ operators form a crystal, and so we get a whole host of amazing consequences for the combinatorial information about $V(\lambda)$:

1. The [weight]{.defn} of an LS path $\pi$ is its ending point $\pi(1)$. The dimension of the $V(\lambda)_\mu$ weight space is the number of LS paths of shape $\lambda$ of weight $\mu$.
2. Call a path $\pi$ of weight $\mu$ [dominant]{.defn} if the translated image $\mu + \pi([0, 1])$ is contained in the dominant chamber ($\mu$ being a dominant weight is necessary, but not sufficient, for $\pi$ to be dominant). Then the multiplicities of irreducibles in the tensor product $V(\lambda) \otimes V(\mu)$ are given by the weights $\lambda + \pi(1)$, where $\pi$ runs over all $\mu$-dominant LS paths of shape $\lambda$.


# Rational paths

<figure id="Paths"></figure>


# Implementation

A piecewise-linear path up to reparametrisation can be represented as an ordered list of its "corner" vertices. We can ensure that this list is normalised so that the list does not "stutter" (repeat the same vertex in a row), and no triple of points $(a, b, c)$ has $b$ as a convex combination of $a$ and $c$. It is relatively straightforward to implement the $e_i$ and $f_i$ path operators in this representation. The most annoying obstacle is the fact that Javascript does not have support for rational numbers built-in, and if we were to build our own, it would be terribly inconvenient to use (cannot use comparisons with regular numbers in a nice way, would have to re-implement vector stuff, etc). What I've done instead is implemented piecewise-linear paths using floating-point numbers, but tried to account for some kind of epsilon error in calculations, and round any coordinates that are sufficiently close to being integers. This seems to work pretty well. The LS paths are then the set of paths generated by the straight-line path under the $f_i$ operators.

Another parametrisation of LS paths is more combinatorial, the notion of a [rational $W$-path]{.defn}.
